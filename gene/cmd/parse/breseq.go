package parse

import (
	"errors"
	"fmt"
	// TODO Change to protobuf model
	"github.com/bio-pdv/tools/model"
	"io"
	"log"
	"os"
	"strings"
)

type fileType string
type application string
type appVersion string

const (
	htmlFileType            fileType    = "html"
	breseq                  application = "breseq"
	breseqVers027Number     appVersion  = "0.27"
	nonBreakingSpaceUnicode             = "\u00A0"
	newlineChar                         = "\n"
	emptyChar                           = " "
	minExpectedTables                   = 2
	minExpectedVersCols                 = 2
	minExpectedHeaderRows               = 2
	// TODO Support breseq gd format.

	errInvalidBreseq027HtmlFile  = "breseq 0.27.* HTML file format is the only supported file type right now."
	errInvalidVersTableMsgFmt    = "Invalid Version Table. Error: '%s'\n"
	errVersNotFound              = "Version not found"
	errNoRows                    = "No rows"
	errNotEnoughContent          = "Not enough content"
	errInvalidDataTableMsgFmt    = "Invalid Data Table. Error: '%s'\n"
	errMismatchedLenDTableMsgFmt = "Data table header lengths don't match. Expected: '%d', but got: '%d' headers"
	errMismatchedDataTableMsgFmt = "Data table headers don't match. At index: '%d' expected: '%s', but got: '%s'"

	validVersTableMsg = "Valid Version Table"
	validDataTableMsg = "Valid Data Table"
)

var (
	breseqVers027Prefix = strings.Join([]string{
		"breseq",
		"version",
		string(breseqVers027Number),
	}, "")

	breseq027HtmlDataHeaders = []string{
		"evidence",
		"seq\u00A0id",
		"position",
		"mutation",
		"freq",
		"annotation",
		"gene",
		"description",
	}
)

// MustParseSeqAnnotationDataFilePath is the same as the ParseSeqAnnotationDataFilePath except it
// panics on the error.
func MustParseSeqAnnotationDataFilePath(filePath string, fileType string, appName string, version string) [][]model.SequenceAnnotation {
	result, err := ParseSeqAnnotationDataFilePath(filePath, fileType, appName, version)
	if err != nil {
		log.Fatal(err)
	}

	return result
}

// ParseSeqAnnotationDataFilePath is a filepath-based version of the ParseSeqAnnotationData function.
func ParseSeqAnnotationDataFilePath(filePath string, fileType string, appName string, version string) ([][]model.SequenceAnnotation, error) {
	reader, err := os.Open(filePath)
	if err != nil {
		return nil, fmt.Errorf("Could not open file for parsing. Filepath: '%s'\n", filePath)
	}

	results, err := ParseSeqAnnotationData(reader, fileType, appName, version)
	if err != nil {
		return nil, fmt.Errorf("%s Filepath: %s", err.Error(), filePath)
	}

	return results, nil
}

// ParseSeqAnnotationData is the main method for tokenizing and validating the sequence annotation data
// via the reader interface. It verifies the following:
//  * Sequence annotation file is of an html type. There's a TODO to support gd and other file formats
//    like JSON on an as needed basis.
//  * Sequence annotation file is generated by a supported application type and version. Currently,
//    it only supports breseq version 0.27.*
//  * Ensures the file contains a valid signature and data table. The first table is expected to contain
//    the version row. The second table is expected to contain a single arbitrary row, header, then immediately
//    followed by the data rows.
//
// Returns a slice of slices where each slice represents a single table data was collected from. It can pick up
// multiple tables, if they exist. If there are any errors in parsing, those are returned.
func ParseSeqAnnotationData(reader io.Reader, fileType string, appName string, version string) ([][]model.SequenceAnnotation, error) {
	err := validateSeqAnnotationDataFile(fileType, appName, version)
	if err != nil {
		return nil, err
	}

	return parseBreseq027HtmlFile(reader)
}

func validateSeqAnnotationDataFile(fType string, appName string, version string) error {
	if fileType(strings.ToLower(fType)) != htmlFileType || application(appName) != breseq || appVersion(version) != breseqVers027Number {
		return errors.New(errInvalidBreseq027HtmlFile)
	}

	return nil
}

func isBreseq027(tables []table) bool {
	if len(tables) < minExpectedTables {
		return false
	}

	if !isBreseq027VersTable(tables[0]) {
		log.Println("Invalid Version Table")
		return false
	}

	if !isBreseq027DataTable(tables[1]) {
		log.Println("Invalid Data Table")
		return false
	}

	return true
}

// isBreseq027VersTable checks that the table has a breseq version 0.27
// prefix in the first row of the table.
func isBreseq027VersTable(tTable table) bool {
	if len(tTable) <= 0 {
		log.Println(errInvalidVersTableMsgFmt, errNoRows)
		return false
	}

	versRow := tTable[0]
	if len(versRow) < minExpectedVersCols {
		log.Println(errInvalidVersTableMsgFmt, errNotEnoughContent)
		return false
	}

	versCol := strings.Replace(versRow[1], nonBreakingSpaceUnicode, "", -1)
	versCol = strings.Replace(versCol, newlineChar, "", -1)
	versCol = strings.Replace(versCol, emptyChar, "", -1)

	log.Printf("Validating version: '%s' with prefix: '%s'\n", versCol, breseqVers027Prefix)
	if !strings.HasPrefix(versCol, breseqVers027Prefix) {
		log.Printf(errInvalidVersTableMsgFmt, errVersNotFound)
		return false
	}

	log.Println(validVersTableMsg)
	return true
}

// isBreseq027DataTable checks that the table has at least
// a valid breseq 0.27 header row.
func isBreseq027DataTable(tTable table) bool {
	if len(tTable) <= 0 {
		log.Printf(errInvalidDataTableMsgFmt, errNoRows)
		return false
	}

	if len(tTable) < minExpectedHeaderRows {
		log.Printf(errInvalidDataTableMsgFmt, errNotEnoughContent)
		return false
	}

	// Throw away the first row with the string, "Predicted mutations"
	tHeader := tTable[1]
	if len(tHeader) <= 0 || len(tHeader) != len(breseq027HtmlDataHeaders) {
		log.Printf(errMismatchedLenDTableMsgFmt, len(breseq027HtmlDataHeaders), len(tHeader))
		return false
	}

	for i, header := range breseq027HtmlDataHeaders {
		if tHeader[i] != header {
			log.Printf(errMismatchedDataTableMsgFmt, i, tHeader[i], header)
			return false
		}
	}

	log.Println(validDataTableMsg)
	return true
}

func parseBreseq027HtmlFile(reader io.Reader) ([][]model.SequenceAnnotation, error) {
	results := [][]model.SequenceAnnotation{}
	tables, err := parseDataTableHtmlTokenizer(reader)
	if err != nil {
		return nil, err
	}

	if !isBreseq027(tables) {
		return nil, fmt.Errorf(errInvalidBreseq027HtmlFile)
	}

	// Skip the first table, which is the versions table.
	for i := 1; i < len(tables); i++ {
		table := tables[i]
		if len(table) > 0 {
			sATable := changeBreseq027TableToSeqAnnotation(table)
			results = append(results, sATable)
		}
	}
	return results, nil
}

// changeBreseq027TableToSeqAnnotation assumes the ordering of the columns were verified
// to be in order before running.
func changeBreseq027TableToSeqAnnotation(dataTable table) []model.SequenceAnnotation {
	if !isBreseq027DataTable(dataTable) {
		return nil
	}

	results := []model.SequenceAnnotation{}
	// Skip the throw away and header rows.
	//  * First row is just the string, "Predicted mutations".
	//  * Second row is the header with:
	//     * evidence
	//     * seq id
	//     * position
	//     * mutation
	//     * freq
	//     * annotation
	//     * gene
	//     * description
	for i := 2; i < len(dataTable); i++ {
		dataRow := dataTable[i]
		sa := model.SequenceAnnotation{
			SequenceId:  dataRow[1],
			Position:    dataRow[2],
			Mutation:    dataRow[3],
			Frequency:   dataRow[4],
			Annotation:  dataRow[5],
			Gene:        dataRow[6],
			Description: dataRow[7],
			Application: string(breseq),
			AppVersion:  string(breseqVers027Number),
		}
		results = append(results, sa)
	}
	return results
}
